<h2> Информационная страница сервиса управления музыкальным медиа контентом.<br> <b> Версия 2.9.7 (август 2021)</b></h2>
<a name="Contents"><h3> Содержание </h3></a>
<ul>
<li><a href="#Назначение и краткое описание">Назначение и краткое описание</a></li>
<li><a href="#Причины создания">Причины создания</a></li>
<li><a href="#Особенности технической реализации и пользователькие функции"> Особенности технической реализации и пользователькие функции</a></li>
<li><a href="#Архитектура системы">Архитектура системы</a></li>
<li><a href="#Установка системы">Установка системы</a></li>
<ul>
<li><a href="#Необходимые пакеты python">пакеты python</a></li>
<li><a href="#Необходимые библиотеки JS">библиотеки JS</a></li>
</ul>
<li><a href="#Версии">Версии</a></li>


</ul>




<a name="Назначение и краткое описание"><h3> Назначение и краткое описание </h3></a>
<b> !!! Вся информация устарела, winamp отключен, работа только с mpd!!!</b>
<p>
  
  Сервис предназначен для централизованного управления процессом воспроизведения музыки и навигации по хранилищу музыкальных файлов большого объема. Концепция сервиса базируется на уже существующих , созданных в ручную или динамически сгенерированных системой плейлистах, или по русски списках проигрывания в формате <b>m3u</b>. <br><br>
  
  Уже существующие списки воспроизведения - это списки библиотеки Winamp, они импортируются в систему и объединяются в определенные заранее группы, это упрощает поиск нужного списка проигрывания.

  <br><br>  Также используются плейлисты динамически создаваемые в процессе использования системы. Такие списки проигрывания генерируются на основе результатов поиска, а также на основе логических тэгов. <br><br> 
<a href="#Contents"> к содержанию </a>
</p>
<a name="Причины создания"><h3> Причины создания </h3></a>
Ставшее нормой наличие у пользователей PC больших объемов музыкального материала, измеряющегося часто десятками тысяч наименований, требует новых подходов к процессу использования всего этого объема. Сложные задачи навигации по такому хранилищу, поиска, хранения т.е. задачи управления этим массивом накладывают определенные требования на программное обеспечение. <br><br> 

В данном случае побудительной причиной начала создания данного приложения послужило отсутствие функции группировки плейлистов в популярном медиапроигрывателе Winamp. Данная фукция не реализована там до сих пор (конец 2010 года). Сложности стали возникать после того, как количество списков проигрывания Winamp перевалило за сотню. При этом очевидно, что охватить листами все множество постоянно пополняемого музыкального материала просто невозможно.<br><br> 

Случайно обнаруженное в сети программный интерфейс API к этому плееру на языке Python позволил автору реализовать первый прототип - оболочку над Winamp. <br><br> 
Требования к первой версии были простыми: во первых - это Web интерфейс, позволяющий доступ к серверному приложению с любого компьютера домашней сети, вторым требованием являлась группировка, созданных в ручную плейлистов Winamp в определенные тематические группы.<br><br> 

Летом 2009 года прототим был готов и позволил проверить предложенную концепцию с группировкой списков проигрывания. Результат был следующий. Из плюсов - действительно группировка по созданным за долгое время в ручную листам сильно облегчала жизнь, а web интерфейс гораздо удобнее классического windows приложения в плане универсальности доступа к нему.<br><br> 

С другой стороны в процессе использования прототипа, стала ясной проблема невозможности охвата плейлистами всей музыкальной библиотеки, а задача поддерживания листов в актуальном состоянии также очень сложная. <br><br> 

Поэтому главным требованием ко второй версии системы было добавление к ней функций поиска. Весной 2010 года прототип второй версии был готов.<br><br> 
Наличие поиска в совокупности с собранной базой метаданных всей музыкальной библиотеки позволило по новому взглянуть на весь музыкальный архив и качество получаемых метаданных. И сейчас основной задачей является качественная навигация по библиотеке в условиях ее постоянно растущего объема,  большого многообразия поддерживаемых медиаформатов, а также логической неконсистентностью метаданных, обусловленной широким спектром источников получения контента в медиа библиотеку. 

В частности сейчас решаются задачи полуавтоматической логической кластеризации материала, что позволит более удобную и интересную навигацию. Вторым направлением работ является опять полуавтоматическое приведение метаданных к "общему знаменателю". Разговор идет о проблемах связанных с различным названием одних и тех же артистов, названия песен и т.д.
<br><br> 

<a href="#Contents"> к содержанию </a>
<a name="Особенности технической реализации и пользователькие функции"><h3> Особенности технической реализации и пользователькие функции </h3></a>
<p>
Плейлист в системе, как правило большой длины, и содержит часто несколько десятков, а иногда и несколько сотен композиций. Для пользователя он автоматически разделяется на альбомы (папки). Можно переходить к предыдущему или следующему альбому в рамках данного листа, используя кнопки <b>"A<--"</b> и <b>"-->A"</b> . В рамках альбома можно делать выборку любой композиции. Как в любом плеере реализованы кнопки <b>Play,Stop,Pause,Next,Prev, перемотки вперед и назад</b>.
</p>

<p>
Поддерживаются форматы <b>mp3</b>, <b>ape</b> (Monkey audio),<b>flac</b>. Для ape и flac реализована поддежка образов диска с использованием карты образа в формате <b>CUE</b>.
</p>

<p>
Интерфейс управления представлен 5ю закладками: <b>Main</b>,	<b>Search</b>, <b>Admin</b> и </b>Info</b>.
В закладке <b>Main</b> основной элемент - это таблица-фрейм плейлиста, где показана предыдущая, текущая и следующая композиции. Для текущей композиции справа показывается обложка диска.
</p>

<p>
Для облегчения сохранения картинок к дискам в закладке <b>Admin</b> можно ввести url картинки из internet, которая будет сохранена в папке текущей композиции. 
</p>
<h4>Данный функционал деактивирован.</h4>
<p>
Реализовано автоматически сохранение истории, для последних 200 композиций. Есть возможность сохранение понравившейся композиции - "Favorites" -> вкладка Main -> кнопка плеера <b>"-->F"</b>.  В закладке Control можно выбрать композицию из списка истории или из Favorites. 


</p>
<a href="#Contents"> к содержанию </a>
<p>
<a name="Архитектура системы"><h3> Архитектура системы </h3><a>

Функционал системы реализован через взаимодействие следущих компонентов:<br>
1. RPC сервер-контроллер плеера WinAmp. Выполняет пришедшие через RPC простейшие команды управления медиаплеером, возвращая назад текущее состояние плеера в виде специальных структур состояний<br>
2. RPC сервер-контроллер приложения - реализует всю логику приложения, вызывает через rpc функции контроллера плеера winamp <br>
3. WEB сервер Apache - принимает запросы и передает их обработку серверу приложения через WSGI интерфейс<br>
4. WSGI интерфейс (hello.wsgi и image.wsgi рассположены в дирректории сервера Apache) отвечает за связь Apache и контроллера приложения. WSGI принимает транслируемый сервером Apache серез mod_wsgi запрос от клиента, делает его первичную обработку и передает далее контроллеру приложения, где этот запрос маршрутизируется в соответсвии со схемой маршрутизации, в результате чего определяются соответствующие методы изменения модели и методы представления. <br><br>

<h4>Загрузка нового плейлиста</h4>
Особенность текущей реализации состоит в том, что обмен данными и командами между контроллером плеера и приложением существует только в рамках уже загруженного в плеер листа. Загрузка нового листа может быть произведена в любой момент, сторонней программой или пользователем операционной системы или же контроллером приложения.
Сервер плеера постоянно возвращает в контроллер приложения контрольную сумму текущего листа, если контрольные суммы не совпадают, то приложение делает пересинхронизацию метаданных текущего плейлиста в модели. Это происходит в контроллере команд приложения вызовом функции модели RefreshServerContent. Новый лист ставиться в начало очереди, предыдущий лист уходит на вторую позицию.
<BR>
Таким образом загрузка плейлиста, есть неявный процесс обмен данными между приложением и плеером, минуя контроллер плеера. Сгенерированный приложением лист сохраняется в файл и ОС дается команда на его исполнение. ОС через файловую систему передает его в winamp. Это эдентично, запуску любого плейлиста сами пользователем через ОС. Приложение при каждом обращении с контроллером плеера проверяет консистентность своего листа и листа у плеера.
<BR>
Пока такая концепция работает без сбоев. Но в целях унификации обмена данными, а также при использовании в перспективе других плееров, было бы корректнее передавать лист напрямую в контроллер плеера, который в свою очередь уже сам принимал бы решение как загрузить лист в плее либо через файловую систему, как сейчас, либо через API к плееру. 
<BR>
Это одно из слабых мест в архитектуре, но это решение дает наиболее быстрый ответ от плеера в частности Winamp. В случае передачи напрямую в winamp посредством функции IPC_ENQUEUEFILE = 100, при открытом окне плейлиста ответ от плеера приходит только после прочитывания данных о файлах. Для листо в 1500 записей это 10 секунд. против 2 без открытого окна.
<BR><BR>
Что касается API плеера в общем случае. То требования к такому API следующие:
<UL>
<li>1. Возможность передачи плейлиста через АPI минуя файловую систему - нет ни у какого известного автору плеера</li>
<li>2. Стандартные операции с позициями листа: вперед, назад, стоп, пауза, проиграть. - есть у всех стандартных плееров</li>
<li>3. Возврат длины текущего листа. -> Winamp Ok</li>
<li>4. Переход на определенную позицию в листе  -> Winamp Ok</li>
<li>5. Возврат позиции текущей композиции в листе  -> Winamp Ok</li>
<li>6. Возврат имени файла текущей композиции в листе  -> Winamp Ok</li>
<li>7. Переход на и возврат позиции текущей играемой композиции в милисекундах  -> Winamp Ok</li>
<li>8. Возврат времени текущей композиции в секундах  -> Winamp Ok</li>
<li>9. Возврат общей информации о формате, битрейте, частоте играемой композиции</li>
<li>10. Возврат текущего состояния плеера, проигрышь, стоп, пауза.</li>
</UL>



</p>
<a href="#Contents"> к содержанию </a>
<p>

<a name="Установка системы"><h3> Установка системы </h3></a>
<a name="Необходимые пакеты python"><h4>Необходимые пакеты python:</h4></a>
1. Python 2.6<br>
2. sqlite (sqlite3) База метаданных приложения<br>
3. win32gui - требуется для winamp API (wynamp.py)<br>
3. PIL (image) - обработка изображений<br>
4. mutagen - получение метаданных из медиафайлов<br>
5. wx . wxPython . gui библиотека - нужно убрать из проекта, переведя административные отчеты в webGui<br>
<br>

<a name="Необходимые библиотеки JS"><h4>Необходимые библиотеки JS:</h4></a>
1. Jquery<br>
3. Knockoutjs - MVVM архитектурный шаблон на клиенте<br>
4. Arbor.js визуализация графов<br>
5. slider - слайдер перемотки<br>

<br>
<h4>Модули и элементы структуры системы.</h4>
<b>Следующие модули необходимы для загрузки серверов приложения и плеера, должны быть явно загружены, лучше сразу при старте ОС: <br></b>

	1. _appl_server.py - загрузчик RPC-сервера-контролера приложения<br>
	2. _player_server.py - загрузчик RPC-сервера-контролера медиаплеера Winampa<br>
	3.  task_dispatcher.py - резидентный диспетчер выполнения сервисных задач, взаимодействует через базу данных с закладкой Admin<br><br>
<b>Ниже приведены модули базовых классов<br>	</b>
	4. mediaLib_controller.py - модуль класса контроллера  MVC (Controller)<br>
	5. myMediaLib_model.py  - модуль класса модели MVC (Model) и класса контроллера медиаплеера Winamp <br>
	6. myMediaLib_view.py -  модуль класса представлений MVC (View)<br><br>

<b>Ниже приведены модули WSGI интерфейса<br>	</b>	
	Эти модули расположены в дирректории "../Apache2.2/myapps/medialib/", см. конфигурационный файл Apache.<br>
	7.  hello.wsgi - прием комманд управления (запросов) клиента и их трансляция в сервер приложения, возвращает назад новый или обновленный ресурс (html страницу) <br>
	8.  image.wsgi - прием запросов на получение изображений и их транслящия в сервер приложений, возвращает назад запрошенное изображение<br><br>

<b>Модули содержашие сервисные фукции	<br></b>
	
	9. myMediaLib_adm.py - содержит сервисные функции работы с базой данных<br>
	10. mediaLibCheck.py - сервисная исполняемая программа: отчеты о целостности списков, удаление несуществующих трэков из базы, обновление базы, перезагрузка базы. <br><br>

<b> CSS стили, Javascript, статические изображения кнопок	<br></b>	
	11. css стили расположены в дирректории "../Apache2.2/htdocs/css/style.css"<br>
	12. javascript - пока является частью шаблона страницы, небольшая часть функций общего уровня перемещена в модуль  "../Apache2.2/htdocs/js/mylib.js"<br>
	13. статические изображения кнопок загружаются самим приложением и передаются через WSGI интерфейс <br>
	14. остальные изображения могут находится в дирректории Apache -"../Apache2.2/htdocs/image/"<br><br>
	
<b> Шаблоны представлений (html шаблоны)	<br></b>
	В целях отделения структуры и вида представлений (html страниц) от общей логики приложения и самого процесса генерации страниц, статические части представлений помещены в шаблоны. Шаблоны расположены в дирректориях определенных в переменной <b>'templatesPath'</b> конфигурационного файла <b>mymedialib.cfg</b>. Структура загрузки шаблонов определена в конфигурационном файле <b>templates.cfg</b>. <br><br>
	Шаблон может соответствовать одной странице, а может определять структуру ее отдельного элемента и быть включенным как переменная в другой шаблон. Например, общий элемент всех страниц - верхнее горизонтально меню помещено в отдельный шаблон <b>bookmarks.tmpl</b>. <br><br>
	Сами шаблоны представляют собой по сути html файлы со вставками переменных в форме стандартного шаблонизатора Python в виде %(имя_переменной)s. Переменные подменяются при генерации представления динамически формируемыми элементами. К сожалению пока в шаблонах невозможно использовать условия и циклы. И часть статической структуры представления для некоторых элементов все еще формируется непосредственно в приложении. Планируется в будующем использовать сторонний шаблонизатор для решения этой проблемы.<br><br>

Шаблоны загружаются в память приложения при старте системы, также имеется возможность быстрой перезагрузки всей структуры шаблонов или даже использования другой структуры, это удобно для отладки структуры нового представления. Для этого в закладке <b>Admin</b> надо выбрать желаемую для загрузки систему шаблонов <b>Load Templates from:</b> и нажеть кнопку <b>Go</b>.	<br><br>
	
<h4>Следующие пакеты должны находится в дирректории проекта.</h4>
1. wynamp.py<br>
2. easygui . нужно избавляться переведя административные фукции в webGui<br>
3. BeautifulSoup.py - парсинг XML нужен для работы с библиотекой плейлистов winamp<br>
<br>
<h4>Обязательное ПО:</h4>
1. Winamp 5.572 (проверено), с установленной библиотекой + плагины <a href="http://www.winamp.com/plugin/cue-player/143011">CUE</a>  и monkey audio (ape) версия MonkeyAudio-3.99b<br>
2. Apache 2.2<br>

<h4>Конфигурационный файл приложения:</h4>
Файл, находящийся в корневом каталоге программы - <b>mymedialib.cfg</b> - содержит основные настройки всего приложения и его окружения.<br><br>
В нем необходимо определить следующие обязательные переменные:<br><br>
<b>mediaPath</b> = <Путь к дирректории winamp lib, где лежат плейлисты winamp, из пути убрать \Plugins\ml><br>
<b>audio_files_path_list</b> = <Путь к дирректориям, где лежат непосредственно музыкальные файлы, можно указывать несколько дирректорий><br>
<b>templatesPath</b> = <Путь к конфигурационному файлу шаблонов, можно использовать несколько систем шаблонов расположенных разных папках. Дополнительные системы шаблонов регистрируются в повторной переменной templatesPath = <путь 2>><br>
<b>winampext</b> = m3u8 - рассширение плейлистов Winamp<br>
<b>player_cntrl_port</b> = 9000 - порт сервера-контроллера winamp<br>
<b>appl_cntrl_port</b> = 9001 - порт сервера основного плиложения<br>

<h4>Файл-схема маршрутизации http json запросов и методов контроллера и представления в архитектуре MVC:</h4>
Во время старта при инициализации класса Controller MVC (MediaLib_Controller) система считывает конфигурационный файл маршрутизации комманд-запросов - 'command_routing.rtg', находящийся в папке шаблонов. Схема маршрутизации конвертируется с словать python через json.
<br><br>
В схеме применяются следющие соглашения:<br>
Первый уровень иерархии схемы - группа комманд. Например, группа комманд инициализации главной страницы управления 'main' - initial_main_load, или група 'page_load' начальной загрузки страниц ('main', 'admin', 'info'), или группа базовых фукций медиаплеера 'player_control'.<br><br>
Второй уровень - название самих комманд.<br><br>
Каждая комманда должна быть связана : <br><br> 
1. с вызовом метода контроллера MVC изменяюшего модель - <b>'model_update_method'</b>, если изменения не нужны, то использовать метод заглушку 'do_nothing'. Заглушка используется например для GET запросов, когда нет необходимости в изменении состояния модели MVC <br><br> 
2. с методом генерации/обновления представления <b>'view_method'</b>.<br><br> 
3. со списком ключей объектов элементов представления <b>'view_elem_id_Dic'</b>. Объекты элементы представления - это те части, из которых состоит конкретное представления, например пыпадающие списки альбомов 'albumL' или тройной фрейм 'предыдущая-текущая-следующая' комозиций на главной страницы управления.<br><br>
4. с именем шаблона, который нужен для генерации данной страницы - <b>'view_template'</b> . !!!Данная функция пока не реализована!!!.

Комманда может быть также связана с логическим процессом, состояние которого изменяется разными управлюящими элементами на разных страницах - закладках. Фильтрация по имени процесса нужна облегчает логику метода-маршрутизатора 'command_dispatcher' класса 'MediaLib_Controller'.
<br><br> 
Такой подход позволяет упростить процесс внесения изменений в программу, за счет избавления от огромного оператора условного перехода. Соответсвующие методы изменения модели или генерации представлений вызываются автоматически в методе 'command_dispatcher' класса MediaLib_Controller. <br><br> 

При этом используется договоренность, что любой "POST" запрос пришедший в WSGI интерфейс - это json объект сгенерированный на стороне клиента.<br><br> 

Любой 'GET' запрос - означает в общем случае просто запрос на начальный показ страницы.  Единственная задача WSGI для GET случая только определить с URL какой страницы (закладки) пришел запрос.<br><br> 

Одновременно с этим сильно упрощена задача определения маршрутизации в WSGI интерфейсе. Его задача сводится только к вычленению запроса из WSGI окружения. Формирование JSON объекта и его передачу в контроллер MVC.<br><br> 

Комментарий. Эта концепция сейчас практически проверяется. Есть ряд открытых вопросов. <br><br> 


<h4>Конфигурация webserwer Apache:</h4>
1. httpd.conf:<br>
LoadModule wsgi_module modules/mod_wsgi.so ---> модуль WSGI<br>

2. Файл CSS стилей находиться в дирректории:<br>
C:\Program Files\Apache Software Foundation\Apache2.2\htdocs\css<br><br>

"<"IfModule wsgi_module">" <br>
WSGIScriptAlias /medialib "C:/Program Files/Apache Software Foundation/Apache2.2/myapps/medialib/hello.wsgi"<br>
WSGIScriptAlias /images "C:/Program Files/Apache Software Foundation/Apache2.2/myapps/images/image.wsgi"<br>
"<"/IfModule">"<br>
Первая строка путь к программе WSGI дисптчеру приложения<br>
Первая строка путь к программе WSGI дисптчеру обработки запросов на изображения<br>

"<"Directory "C:/Program Files/Apache Software Foundation/Apache2.2/myapps"">"
Order allow,deny
Allow from all
</Directory>
Путь к дирректории WSGI интерфейсов <br>
<a href="#Contents"> к содержанию </a>
<p>
<a name="Версии"><h3> Версии </h3></a>
</p>
<h4>Версия 2.9.0  </h4>
<p>
 Осень - Зима 2012 <br>
 
<ul>
<li> 1. Топологическая навигация интегрирована в плеер, доступны объекты: композитор, двойной альбом, серии и т.д. </li>
<li> 2. ПЛАН 2.9. Общая многовекторная категоризация (создание, редактирование, использование в плеере) </li>
<li> 3. ПЛАН 2.9. Режим навигации (предварительного просмотра) по топологическим и категоризационным связям со вверткой в узловых элементах </li>
<li> 4. ПЛАН 2.9. Трэковая классификация (интеграция трэков в классификационное пространство альбомов и артистов) </li>
<li> 5. ПЛАН 3.0. Переход на концепцию автоматического порционного проигрывания по заданию, в отличие от использовавшейся концепции проигрывания полного сгенерированного листа </li>
<li> 6. ПЛАН 3.0.. Использование референтной базы метаданных </li>
 
</ul>
<BR>

<a href="#Contents"> к содержанию </a>
<h4>Версия 2.9.7 </h4>
<p>
        Август - Сентябрь 2021. linux port  <br>
 <ul>

<li> 1. Портирование на линукс Debian 10 и Ubuntu 20</li>
<li> 2. Проект перенесен на GitHub https://github.com/Igorigorizh/MediaLibManager.git </li>
<li> 3. Адаптация кода для работы в Docker, поставка с помощью doker-compose </li>
</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>
<h4>Версия 2.9.6 </h4>
<p>
        Август 2021. асинхронные вызовы MPD инстанций  <br>
 <ul>
<li> 1. Решена проблема 10-и секундной задержки в вызовах MPD. </li>
<li> 2. Решена прорлема 4-х секундной задержки с удаленных устройств, внутренние сетевые обращения теперь только через IP адрес. Проблема в долгом разрешение доменного имени </li>
</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>
<h4>Версия 2.9.5 </h4>
<p>
        Декабрь 2020 - Март 2021. Работа с клиентами по имени домена или ip адресу  <br>
 <ul>
<li> 1. Клиенты теперь могут работать с web приложением также по ip адресу. Это дало возможность работать с мобильных устройств. </li>
<li> 2. Выбор рабочей mpd инстанции прямо из навигатора </li>
<li> 3. План. Назначение тэгов на категории по аналогии с артист/альбом. запуск из навигатора </li>
<li> 4. План. Адаптивная верстка CSS под мобильные устройства</li>
</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>
<h4>Версия 2.9.4 </h4>
<p>
        Декабрь 2019 - Зима 2020. Переход на Python 3, отключение winamp, переход к MPD  <br>
 <ul>
<li> 1. Миграция всего кода и зависимостей на Python 3, использование Apache 2.4 </li>
<li> 2. Переход на MPD. Полный отказ от winamp </li>
<li> 2.1 Отключение зависимости от работающего плеера, работа с метаданными может вестись назависимо от наличия плеера</li>
<li> 2.2 Работа с несколькими инстанциями MPD, можно выбрать рабочую инстанцию MPD и все дальнейшие действия ведутся с ней </li>
<li> 2.3 Новая схема генерации trackCRC32 на основе оригинального медиа файла  </li>
<li> 2.4 Решена проблема с обратной выгрузкой плейлиста из MPD и идентификацией неоднозначного trackCRC32 для CUE в БД приложения.  </li>

</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>



<h4>Версия 2.9.3 </h4>
<p>
        Осень 2018 - Весна 2019. Относительные имена, частичная интеграция с MPD  <br>
 <ul>
<li> 1. Миграция на относительные имена музыкальный файлов в системе и БД </li>
<li> 2. Прототип отдельного приложения по генерации списков загрузки в MPD по категориям, албомам и артистам .</li>
</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>

<h4>Версия 2.9.2 </h4>
<p>
	Март 2018 - Сентябрь 2018. Миграция на уникод, поддержка потрэковых CUE, навая закладка TracksAdmin  <br>
 <ul>
<li> 1. БД, приложение и интерфейс к плееру мигрированны на unicode, пересчитаны все контрольные суммы объектов БД в unicode. </li>
<li> 2. Новая закладка TracksAdmin для быстрой удаленной регистрации (удалением) новых трэков,альбомов, новых альбомных артистов и их связей.</li>
<li> 2.1 Генерация снимка дерева папок медиаданных, поиск новых файлов в узле по дельте относительно снимка.</li>
<li> 3. Поддержка потрэковых CUE</li>
<li> 4. Запуск из index.html контроллеров плеера, приложения и диспетчера задач. Удаление контроллеров и winamp из /rappl</li>

</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>

 <h4>Версия 2.9.1 </h4>
<p>
	Апрель 2017,Сентябрь 2017 . Прототипы вычисления FingerPrint, Сканы альбомов  <br>
 <ul>
<li> 1. Прототипы функций массового вычисления fingeprints по трэкам. </li>
<li> 2. Обновленные старые прототипы массового получения данных MusicBraizngs.</li>
<li> 3. Новая закладка Images. В ней прототип показа сканов альбомов JPG,PNG,PDF.</li>
<li> 4. Реализован режим обновления существующих станций интернет-радио, ранее было возможно только создание новых. Сейчас URL станции обновляется с пересчетом CRC32 связанных объектов</li>
<li> 5. Проверена концепция перехода на плеер MPD, выявлены проблемы с обратной загрузкой CUE листов и русскими именами файлов.</li>
</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>
 
 <h4>Версия 2.9 </h4>
<p>
 Зима 2015 - 2016. Перенос на Win8/Win10. Интернет радио.  <br>
 <ul>
<li> 1. Серверная часть перенесена на Win8/Win10. Произведен рефакторинг кода. Исправлены выявленные ошибки. </li>
<li> 2. Добавлены сервисные функции: лог ошибок, статус работы, отладочная информация, перезагрузка системы.</li>
<li> 3. Проверена возможность работы системы а полном автономном режиме.</li>
<li> 4. Реализован режим интернет-радио.</li>
</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>


<h4>Версия 2.8 </h4>
<p>
 Весна 2012 - Лето 2012. Новый клиентский плеер с альбомным представлением. <br>
 
<ul>
<li> 1. Сделан плеер с альбомным представлением в виде слайдера, реализовано отображение топологической навигации, автопоиск по артисту,альбому и тэгу. Представление списка трэков меняется в зависимости от типа листа (альбомы одного артиста или разные). </li>
<li> 2. Реализован режим синхронизирования контекста всех активных клиентских инстанций во время проигрывания по технологии long-pooling.</li>
<li> 3. Пулуавтоматическое выявление и сохранение двойных альбомов и серий на основе схожести имен. </li>
<li> 4. Сделана функция конфигурирования(рафинирования) отдельного объекта типа Артист, Альбом и всевозможных категоризационных связей и их сохраненных в БД.</li>
<li> 5. Категоризационный табличный навигатор показывает связанных артистов и альбомы, использую топологическую связь можно переходить от артиста к альбому и наоборот. Учитываются узловые альбомные объекты, с возможность показа обложки узлового объекта, если он доступен или обложки 1-го объекта ниже по иерархии</li>
</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>


<h4>Версия 2.7 </h4>
<p>
 Зима 2011 - Весна 2012. <br>

<ul>
<li> 1. Изменена клиентская архитектура. Данные для закладок report, и граф генерируются на сервере как json объекты, а само представление формируется на клиенте. Использована библиотека Knockoutjs. Снята сильная зависимость от генерации HTML представления на сервере. Представление генерируется на клиенте, на основе json данных сервера.</li>
<li> 2. Введен новый объект Альбом.</li>
<li> 3. Реализована ключевая процедура массовой начальной полуавтоматической загрузки и сохранения объектов Артист,Альбом и их связи в БД на основе метаданных трэков.</li>
<li> 4. Сделана функция конфигурирования(рафинирования) отдельного объекта типа Артист, Альбом и всевозможных категоризационных связей и их сохраненных в БД.</li>
<li> 5. Сделана функция массового назначения объектов на категории.</li>
<li> 6. Создано альтернативное табличное представление категоризации в закладке граф</li>
</ul>
<BR>
<a href="#Contents"> к содержанию </a>
</p>

<h4>Версия 2.6:</h4>
<p>
Лето - Осень 2011. <br><br>
Проверены следующие концепции и сделаны прототипы:<br>
<ul>
<li> Графическая визуализация отчетов (js библиотека arbor); связь тэгов и артистов </li>
<li> Начальная страницы выбора жанровых листов  (js библиотека arbor) -> новая закладка graf </li>
<li> Debug страница с возможностью выбора объектов из модели -->урл /debug </li>
<li> Выдача отладочной информации в лог файл и консоль через стандартный python логгинг, уровень логера задается на административной странице. По умолчачию настроен только на критические ошиблки. </li>
<li> Сделан прототим системы аудио по запросу на основе плеера jplayer </li>
<li> Реализована сервисная утилита репликации lossless контента в mp3 и ogg для проекта аудио по запросу. Сделаны реплики со всей библиотеки. </li>
<li> На основной странице сделан слайдер ручной перемотки </li>
<li> Новый поиск с выдачей результатов с динамическими активными тэгами или с изображением альбомов, при этом изображение также активный элемент навигации </li>
</ul>
</p>
<p>
Реализация концепции видео по запросу потребовала выделения этого функционала в отдельный проект myMediaLibCast. При этом используется база данных основной системы, выдача lossy контента происходит автоматически через механизм переадрессации контента.
</p>

<p>

</p>
<BR>
<a href="#Contents"> к содержанию </a>
<h4>Версия 2.5:</h4>
<p>
Весна 2011. <br><br>
Добавлена функция регистрации/обновления в базе текущего играемого диска, что существенно ускорило регистрацию новых дисков.
</p>

<p>
Добавлен квази динамический тэг типа "song" на основе старого статического тэга, что разгрузило страку статических тэгов.
</p>


<p>
Изменена логика формироваиия урл картинки, теперь картинка имеет уникальный адрес. Это исправило баг с неправильным показом картинок альбома.
</p>
<BR>
<a href="#Contents"> к содержанию </a>

<h4>Версия 2.4:</h4>
<p>
Осень-Зима 2010. <br><br>
В целях дальнейшего улучшения производительности системы и повышения удобства разработки и внесения изменений в фукционал - принято решение придерживаться архитектурной модели MVC. Улучшение производительности произошло за счет использования технологии ajax. <br><br>. Все закладки кроме Search и все методы POST переведены на новую концепцию. Страницы генерируется один раз, если необходимы изменения, то происходит обновление только тех элементов представления, которые действительно поменялись. Время реакции системы уменьшилось в 2-3 раза. <br><br>
Полностью функционирует форма создания тэгов и назначения трэков на тэги.
</p>

<h4>Версия 2.3:</h4>
<p>
Осень 2010. <br><br>
Система стала заметно быстрее, код разделен на несколько логических частей: фукционал плеера и общий функционал приложения. Учитывая трудоемкость создания тэгов в ручную, решено дополнительно к ручным тэгам генерировать динамические тэги для артистов и альбомов. Эта фукциональность потребовала создания аналитического отчета, в первой версии только для артиста, позволяющего выявлять различные упоминания в базе данных одного и того же артиста. <br><br>
Выявленные различные упоминания объединяются вручную в одну группу. Если при генерации плейлиста по динамическому тэгу затрагивается хотя бы один артист из группы, то автоматически в плейлист добавляются треки с другими упоминаниями этого артиста.
</p>
<BR>
<a href="#Contents"> к содержанию </a>
<h4>Версия 2.2:</h4>
<p>
Июнь 2010.<br><br>
 Учитывая очень медленную работу системы, ее неустойчивость и разросшийся фукционал "все в одном", принято решение о разделении системы на следующие компоненты: контроллер музыкального плеера winamp - взял на себя только основные фукции управления winamp, и контроллер приложения - реализует базовую логику всего приложени и управления метаданными. Контроллеры сделаны как xml RPC сервера. <br><br>
 В качестве веб сервера используется Apache. Для связи сервер-контроллера приложения и web сервера использован WSGI интерфейс.<br> <br>
 Сервер-контроллер плеера используется только через сервер-контроллер приложения<br><br>
Система стала заметно быстрее за счет использования нового winamp Python-API, код разделен на несколько логических частей: фукционал плеера и общий функционал приложения.
</p>
<BR>
<a href="#Contents"> к содержанию </a>
<h4>Версия 2.1:</h4>
<p>
Весна-Лето 2010.<br><br>
 Добавлены логические тэги по условным группам: Артист, Песня, Стиль, Тематическая подборка. Тэги создаются вручную на новой закладке TagAdmin, треки присваиваются тэгу в полуавтоматическом режиме, используя фукцию поиска для отбора нужных композиций.
</p>
<BR>
<a href="#Contents"> к содержанию </a>
<h4>Версия 2.0:</h4>
<p>
Зима-Весна 2010.<br><br>
Добавлено хранилище метаданых на основе sqlite. Новые файлы заносяться автоматически в ситему их метаданные регистрируются в базе. Сделан поиск по базе по полям: автор, название трека, альбом. Если композиция прописана в каком-либо из списков проигрывания, то этот список также показывается при выдачи. Если списков для композиции несколько, есть возможжность перейти на один из них. <br><br>
Возможность автоматической генерации листов на основе поисковой выдачи, вместе с возможностью выбора плейлиста винампа непосредствено из этого же списка поисковой выдачи, очень сильно повысило удобство использования системы. Произошел естественный уход от метода доступа через листы винампа, к доступу через поиск по базе всех музыкальных композиций.
</p>
<BR>
<a href="#Contents"> к содержанию </a>

<h4>Версия 1.0:</h4>
<p>
2009- Зима 2010. Первый прототим системы "все в одном". Реализация через Python web server. Сделаны основные функции управления плеером и навигация по спискам проигрывания winamp (более 200 штук листов созданных вручную). Создано около 20 групп плейлистов. Метаданные аудио файлов читаются на 'лету'. Система работает очень медленно. Количество существующих групп плейлистов явно недостаточно. Для охвата всех аудио файлов необходима трудоемкая ручная работа по занесению их в списки проигрывани. Списки создаются в в Winamp.
</p>

